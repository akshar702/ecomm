{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Output, Input, HostBinding, HostListener, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nfunction CarouselComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.counter);\n  }\n}\nfunction CarouselComponent_ng_template_5_div_0_img_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 11);\n  }\n  if (rf & 2) {\n    const i_r6 = i0.ɵɵnextContext(2).index;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"object-fit\", ctx_r8.objectFit);\n    i0.ɵɵproperty(\"src\", ctx_r8.getImage(i_r6)[\"image\"][\"path\"], i0.ɵɵsanitizeUrl);\n  }\n}\nfunction CarouselComponent_ng_template_5_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_template_5_div_0_img_1_Template, 1, 3, \"img\", 10);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const i_r6 = i0.ɵɵnextContext().index;\n    const ctx_r7 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r7.getCellWidth() + \"px\")(\"border-radius\", ctx_r7.borderRadius + \"px\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.getImage(i_r6) && ctx_r7.getImage(i_r6)[\"image\"]);\n  }\n}\nfunction CarouselComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CarouselComponent_ng_template_5_div_0_Template, 2, 5, \"div\", 8);\n  }\n  if (rf & 2) {\n    const i_r6 = ctx.index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", i_r6 < ctx_r2.cellLimit);\n  }\n}\nfunction CarouselComponent_div_6_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 14);\n  }\n  if (rf & 2) {\n    const i_r13 = ctx.index;\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"carousel-dot-active\", i_r13 === ctx_r11.activeDotIndex);\n  }\n}\nfunction CarouselComponent_div_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtemplate(1, CarouselComponent_div_6_div_1_Template, 1, 2, \"div\", 13);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r3.dotsArr);\n  }\n}\nfunction CarouselComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 15)(1, \"div\", 16);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_div_7_Template_div_click_1_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.prev());\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"div\", 17);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_div_7_Template_div_click_2_listener() {\n      i0.ɵɵrestoreView(_r15);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.next());\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"carousel-arrows-outside\", ctx_r4.arrowsOutside)(\"carousel-dark-arrows\", ctx_r4.arrowsTheme === \"dark\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"carousel-arrow-disabled\", ctx_r4.isPrevArrowDisabled());\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"carousel-arrow-disabled\", ctx_r4.isNextArrowDisabled());\n  }\n}\nconst _c0 = [\"*\"];\nclass Touches {\n  constructor(properties) {\n    this.eventType = undefined;\n    this.handlers = {};\n    this.startX = 0;\n    this.startY = 0;\n    this.lastTap = 0;\n    this.doubleTapMinTimeout = 300;\n    this.tapMinTimeout = 200;\n    this.touchstartTime = 0;\n    this.i = 0;\n    this.isMousedown = false;\n    this._touchListeners = {\n      \"touchstart\": \"handleTouchstart\",\n      \"touchmove\": \"handleTouchmove\",\n      \"touchend\": \"handleTouchend\"\n    };\n    this._mouseListeners = {\n      \"mousedown\": \"handleMousedown\",\n      \"mousemove\": \"handleMousemove\",\n      \"mouseup\": \"handleMouseup\",\n      \"wheel\": \"handleWheel\"\n    };\n    this._otherListeners = {\n      \"resize\": \"handleResize\"\n    };\n    /*\r\n     * Listeners\r\n     */\n    /* Touchstart */\n    this.handleTouchstart = event => {\n      this.elementPosition = this.getElementPosition();\n      this.touchstartTime = new Date().getTime();\n      if (this.eventType === undefined) {\n        this.getTouchstartPosition(event);\n      }\n      this.runHandler(\"touchstart\", event);\n    };\n    /* Touchmove */\n    this.handleTouchmove = event => {\n      const touches = event.touches;\n      // Pan\n      if (this.detectPan(touches)) {\n        this.runHandler(\"pan\", event);\n      }\n      // Pinch\n      if (this.detectPinch(event)) {\n        this.runHandler(\"pinch\", event);\n      }\n      // Linear swipe\n      switch (this.detectLinearSwipe(event)) {\n        case \"horizontal-swipe\":\n          event.swipeType = \"horizontal-swipe\";\n          this.runHandler(\"horizontal-swipe\", event);\n          break;\n        case \"vertical-swipe\":\n          event.swipeType = \"vertical-swipe\";\n          this.runHandler(\"vertical-swipe\", event);\n          break;\n      }\n      // Linear swipe\n      if (this.detectLinearSwipe(event) || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\n        this.handleLinearSwipe(event);\n      }\n    };\n    /* Touchend */\n    this.handleTouchend = event => {\n      const touches = event.touches;\n      // Double Tap\n      if (this.detectDoubleTap()) {\n        this.runHandler(\"double-tap\", event);\n      }\n      // Tap\n      this.detectTap();\n      this.runHandler(\"touchend\", event);\n      this.eventType = 'touchend';\n      if (touches && touches.length === 0) {\n        this.eventType = undefined;\n        this.i = 0;\n      }\n    };\n    /* Mousedown */\n    this.handleMousedown = event => {\n      this.isMousedown = true;\n      this.elementPosition = this.getElementPosition();\n      this.touchstartTime = new Date().getTime();\n      if (this.eventType === undefined) {\n        this.getMousedownPosition(event);\n      }\n      this.runHandler(\"mousedown\", event);\n    };\n    /* Mousemove */\n    this.handleMousemove = event => {\n      //event.preventDefault();\n      if (!this.isMousedown) {\n        return;\n      }\n      // Pan\n      this.runHandler(\"pan\", event);\n      // Linear swipe\n      switch (this.detectLinearSwipe(event)) {\n        case \"horizontal-swipe\":\n          event.swipeType = \"horizontal-swipe\";\n          this.runHandler(\"horizontal-swipe\", event);\n          break;\n        case \"vertical-swipe\":\n          event.swipeType = \"vertical-swipe\";\n          this.runHandler(\"vertical-swipe\", event);\n          break;\n      }\n      // Linear swipe\n      if (this.detectLinearSwipe(event) || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\n        this.handleLinearSwipe(event);\n      }\n    };\n    /* Mouseup */\n    this.handleMouseup = event => {\n      // Tap\n      this.detectTap();\n      this.isMousedown = false;\n      this.runHandler(\"mouseup\", event);\n      this.eventType = undefined;\n      this.i = 0;\n    };\n    /* Wheel */\n    this.handleWheel = event => {\n      this.runHandler(\"wheel\", event);\n    };\n    /* Resize */\n    this.handleResize = event => {\n      this.runHandler(\"resize\", event);\n    };\n    this.properties = properties;\n    this.element = this.properties.element;\n    this.elementPosition = this.getElementPosition();\n    this.toggleEventListeners('addEventListener');\n  }\n  get touchListeners() {\n    return this.properties.touchListeners ? this.properties.touchListeners : this._touchListeners;\n  }\n  get mouseListeners() {\n    return this.properties.mouseListeners ? this.properties.mouseListeners : this._mouseListeners;\n  }\n  get otherListeners() {\n    return this.properties.otherListeners ? this.properties.otherListeners : this._otherListeners;\n  }\n  destroy() {\n    this.toggleEventListeners('removeEventListener');\n  }\n  toggleEventListeners(action) {\n    let listeners;\n    if (this.properties.listeners === 'mouse and touch') {\n      listeners = Object.assign(this.touchListeners, this.mouseListeners);\n    } else {\n      listeners = this.detectTouchScreen() ? this.touchListeners : this.mouseListeners;\n    }\n    if (this.properties.resize) {\n      listeners = Object.assign(listeners, this.otherListeners);\n    }\n    for (var listener in listeners) {\n      const handler = listeners[listener];\n      // Window\n      if (listener === \"resize\") {\n        if (action === 'addEventListener') {\n          window.addEventListener(listener, this[handler], false);\n        }\n        if (action === 'removeEventListener') {\n          window.removeEventListener(listener, this[handler], false);\n        }\n        // Document\n      } else if (listener === 'mouseup' || listener === \"mousemove\") {\n        if (action === 'addEventListener') {\n          document.addEventListener(listener, this[handler], {\n            passive: false\n          });\n        }\n        if (action === 'removeEventListener') {\n          document.removeEventListener(listener, this[handler], false);\n        }\n        // Element\n      } else {\n        if (action === 'addEventListener') {\n          this.element.addEventListener(listener, this[handler], false);\n        }\n        if (action === 'removeEventListener') {\n          this.element.removeEventListener(listener, this[handler], false);\n        }\n      }\n    }\n  }\n  addEventListeners(listener) {\n    const handler = this._mouseListeners[listener];\n    window.addEventListener(listener, this[handler], false);\n  }\n  removeEventListeners(listener) {\n    const handler = this._mouseListeners[listener];\n    window.removeEventListener(listener, this[handler], false);\n  }\n  handleLinearSwipe(event) {\n    //event.preventDefault();\n    this.i++;\n    if (this.i > 3) {\n      this.eventType = this.getLinearSwipeType(event);\n    }\n    if (this.eventType === 'horizontal-swipe') {\n      this.runHandler('horizontal-swipe', event);\n    }\n    if (this.eventType === 'vertical-swipe') {\n      this.runHandler('vertical-swipe', event);\n    }\n  }\n  runHandler(eventName, response) {\n    if (this.handlers[eventName]) {\n      this.handlers[eventName](response);\n    }\n  }\n  /*\r\n   * Detection\r\n   */\n  detectPan(touches) {\n    return touches.length === 1 && !this.eventType || this.eventType === 'pan';\n  }\n  detectDoubleTap() {\n    if (this.eventType != undefined) {\n      return;\n    }\n    const currentTime = new Date().getTime();\n    const tapLength = currentTime - this.lastTap;\n    clearTimeout(this.doubleTapTimeout);\n    if (tapLength < this.doubleTapMinTimeout && tapLength > 0) {\n      return true;\n    } else {\n      this.doubleTapTimeout = setTimeout(() => {\n        clearTimeout(this.doubleTapTimeout);\n      }, this.doubleTapMinTimeout);\n    }\n    this.lastTap = currentTime;\n    return undefined;\n  }\n  detectTap() {\n    if (this.eventType != undefined) {\n      return;\n    }\n    const currentTime = new Date().getTime();\n    const tapLength = currentTime - this.touchstartTime;\n    if (tapLength > 0) {\n      if (tapLength < this.tapMinTimeout) {\n        this.runHandler(\"tap\", event);\n      } else {\n        this.runHandler(\"longtap\", event);\n      }\n    }\n  }\n  detectPinch(event) {\n    const touches = event.touches;\n    return touches.length === 2 && this.eventType === undefined || this.eventType === 'pinch';\n  }\n  detectLinearSwipe(event) {\n    const touches = event.touches;\n    if (touches) {\n      if (touches.length === 1 && !this.eventType || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\n        return this.getLinearSwipeType(event);\n      }\n    } else {\n      if (!this.eventType || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\n        return this.getLinearSwipeType(event);\n      }\n    }\n    return undefined;\n  }\n  getLinearSwipeType(event) {\n    if (this.eventType !== 'horizontal-swipe' && this.eventType !== 'vertical-swipe') {\n      const movementX = Math.abs(this.moveLeft(0, event) - this.startX);\n      const movementY = Math.abs(this.moveTop(0, event) - this.startY);\n      if (movementY * 3 > movementX) {\n        return 'vertical-swipe';\n      } else {\n        return 'horizontal-swipe';\n      }\n    } else {\n      return this.eventType;\n    }\n  }\n  getElementPosition() {\n    return this.element.getBoundingClientRect();\n  }\n  getTouchstartPosition(event) {\n    this.startX = event.touches[0].clientX - this.elementPosition.left;\n    this.startY = event.touches[0].clientY - this.elementPosition.top;\n  }\n  getMousedownPosition(event) {\n    this.startX = event.clientX - this.elementPosition.left;\n    this.startY = event.clientY - this.elementPosition.top;\n  }\n  moveLeft(index, event) {\n    const touches = event.touches;\n    if (touches) {\n      return touches[index].clientX - this.elementPosition.left;\n    } else {\n      return event.clientX - this.elementPosition.left;\n    }\n  }\n  moveTop(index, event) {\n    const touches = event.touches;\n    if (touches) {\n      return touches[index].clientY - this.elementPosition.top;\n    } else {\n      return event.clientY - this.elementPosition.top;\n    }\n  }\n  detectTouchScreen() {\n    var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\n    var mq = function (query) {\n      return window.matchMedia(query).matches;\n    };\n    if ('ontouchstart' in window) {\n      return true;\n    }\n    // include the 'heartz' as a way to have a non matching MQ to help terminate the join\n    // https://git.io/vznFH\n    var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\n    return mq(query);\n  }\n  /* Public properties and methods */\n  on(event, handler) {\n    if (event) {\n      this.handlers[event] = handler;\n    }\n  }\n}\nclass Carousel {\n  constructor(properties, utils, cells, container, slide) {\n    this.properties = properties;\n    this.utils = utils;\n    this.cells = cells;\n    this.container = container;\n    this.slide = slide;\n    /* The slide length has been limited by the limitSlideLength() method */\n    this.isSlideLengthLimited = false;\n    this.isContentImages = true;\n    this.isLazyLoad = true;\n    this.isContainerLocked = true;\n    this.alignCells = \"left\";\n    this.initialContainerPosition = 0;\n    this.containerPullLimit = 100;\n    this.handleTouchstart = event => {\n      this.container.handleTouchstart();\n      this.slide.handleTouchstart(event);\n    };\n    this.handleHorizontalSwipe = event => {\n      this.container.handleHorizontalSwipe();\n    };\n    this.handleTouchend = event => {\n      if (this.properties.freeScroll) {\n        this.container.handleTouchend();\n      } else {\n        this.container.handleTouchend(true);\n        this.slide.handleTouchend(event);\n      }\n    };\n    this.isNextArrowDisabled = () => {\n      return this.slide.isNextArrowDisabled();\n    };\n    this.isPrevArrowDisabled = () => {\n      return this.slide.isPrevArrowDisabled();\n    };\n    this.init();\n  }\n  get cellLength() {\n    return this.cells.cellLength;\n  }\n  get cellLengthInLightDOMMode() {\n    if (this.images) {\n      let cellLength = this.numberOfVisibleCells + this.overflowCellsLimit * 2;\n      if (cellLength > this.images.length) {\n        cellLength = this.images.length;\n      }\n      return cellLength;\n    } else {\n      return this.cellLength;\n    }\n  }\n  get lastCellIndex() {\n    return this.images.length ? this.images.length - 1 : this.cells.cellLength - 1;\n  }\n  get overflowCellsLimit() {\n    return this.utils.overflowCellsLimit;\n  }\n  get cellLimit() {\n    if (this.isLightDOM) {\n      let cellLimit = this.numberOfVisibleCells + this.overflowCellsLimit * 2;\n      if (cellLimit < this.numberOfVisibleCells) {\n        cellLimit = this.numberOfVisibleCells;\n      }\n      return cellLimit;\n    } else {\n      return this.properties.images.length;\n    }\n  }\n  get isLightDOM() {\n    return this.properties.lightDOM || this.properties.loop;\n  }\n  get images() {\n    return this.properties.images;\n  }\n  get margin() {\n    return this.properties.margin;\n  }\n  get minSwipeDistance() {\n    return this.properties.minSwipeDistance;\n  }\n  get transitionDuration() {\n    return this.properties.transitionDuration;\n  }\n  get transitionTimingFunction() {\n    return this.properties.transitionTimingFunction;\n  }\n  get fullCellWidth() {\n    return this.properties.cellWidth + this.margin;\n  }\n  get numberOfVisibleCells() {\n    return this.utils.numberOfVisibleCells;\n  }\n  get lapCounter() {\n    return Math.floor(this.slide.counter / this.cellLengthInLightDOMMode);\n  }\n  get slideCounter() {\n    return this.slide.counter;\n  }\n  updateProperties(properties) {\n    this.properties = properties;\n  }\n  init() {\n    this.cellsElement = this.properties.cellsElement;\n    this.visibleWidth = this.properties.visibleWidth || this.cellsElement.parentElement.clientWidth;\n  }\n  destroy() {\n    clearInterval(this.autoplayId);\n  }\n  lineUpCells() {\n    this.cells.lineUp();\n  }\n  handleTransitionend() {\n    this.slide.handleTransitionend();\n  }\n  getImage(index) {\n    return this.cells.getImage(index);\n  }\n  next(length = 1) {\n    if (!this.isNextArrowDisabled()) {\n      this.slide.next(length);\n    }\n  }\n  prev(length = 1) {\n    this.slide.prev(length);\n  }\n  autoplay() {\n    this.autoplayId = setInterval(() => {\n      this.next();\n    }, this.properties.autoplayInterval);\n  }\n  stopAutoplay() {\n    if (this.autoplayId) {\n      clearInterval(this.autoplayId);\n    }\n  }\n}\nclass Container {\n  constructor(carouselProperties, utils, cells) {\n    this.carouselProperties = carouselProperties;\n    this.utils = utils;\n    this.cells = cells;\n    /* The index of the new position relative to\r\n     * the active index, for example -1 or +1\r\n     */\n    this.newPositionIndex = 0;\n    this.isPositionCorrection = false;\n    this.initialPositionX = 0;\n    this.initialElementPositionX = 0;\n    this.isLocked = true;\n    this.pullLimit = 100;\n    this.startTime = 0;\n    this.startX = 0;\n    this.moveX = 0;\n    this.isSwipeInProgress = false;\n    this.init();\n  }\n  get visibleWidth() {\n    return this.utils.visibleWidth;\n  }\n  get overflowCellsLimit() {\n    return this.utils.overflowCellsLimit;\n  }\n  get images() {\n    return this.carouselProperties.images;\n  }\n  get element() {\n    return this.carouselProperties.cellsElement;\n  }\n  get freeScroll() {\n    return this.carouselProperties.freeScroll;\n  }\n  get fullCellWidth() {\n    return this.carouselProperties.cellWidth + this.carouselProperties.margin;\n  }\n  get numberOfVisibleCells() {\n    return this.utils.numberOfVisibleCells;\n  }\n  get transitionDuration() {\n    return this.carouselProperties.transitionDuration;\n  }\n  get transitionTimingFunction() {\n    return this.carouselProperties.transitionTimingFunction;\n  }\n  get cellLength() {\n    if (this.images) {\n      return this.images.length;\n    } else {\n      return this.cells.cellLength;\n    }\n  }\n  get cellLengthInLightDOMMode() {\n    if (this.images) {\n      let cellLength = this.numberOfVisibleCells + this.overflowCellsLimit * 2;\n      if (cellLength > this.images.length) {\n        cellLength = this.images.length;\n      }\n      return cellLength;\n    } else {\n      return this.cellLength;\n    }\n  }\n  get tooFewCells() {\n    return this.numberOfVisibleCells > this.cellLength;\n  }\n  get disabled() {\n    return this.tooFewCells;\n  }\n  get margin() {\n    return this.carouselProperties.margin;\n  }\n  get isLightDOM() {\n    return this.carouselProperties.lightDOM || this.carouselProperties.loop;\n  }\n  updateProperties(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n  }\n  init() {\n    this.setWidth();\n  }\n  handleTouchstart() {\n    this.startX = this.utils.getStartX(event);\n    this.startTime = new Date().getTime();\n    this.initialElementPositionX = this.getInitialElementPositionX();\n  }\n  handleHorizontalSwipe() {\n    if (this.disabled) {\n      return;\n    }\n    if (!this.isSwipeInProgress) {\n      this.startX = this.utils.getStartX(event);\n      this.startTime = new Date().getTime();\n      this.initialElementPositionX = this.getInitialElementPositionX();\n    }\n    this.isSwipeInProgress = true;\n    this.moveX = this.utils.getMoveX(event);\n    this.move();\n  }\n  handleTouchend(simpleProcessing = false) {\n    if (this.disabled) {\n      return;\n    }\n    /* If touchend was passed to the Slide class */\n    if (simpleProcessing) {\n      this.isSwipeInProgress = false;\n      return;\n    }\n    this.isSwipeInProgress = false;\n    this.finishMoving();\n    this.clearInitialValues();\n  }\n  move() {\n    let positionX = this.getMovePositionX();\n    const isPulled = this.detectPulled();\n    const direction = this.getDirection();\n    if (isPulled) {\n      if (isPulled.edge === \"left\" && direction === \"right\" || isPulled.edge === \"right\" && direction === \"left\") {\n        positionX = this.slowdownOnPull(positionX);\n      }\n    }\n    this.transformPositionX(positionX, 0);\n    if (this.freeScroll) {\n      this.initialPositionX = positionX;\n    }\n    if (isPulled) {\n      if (isPulled.edge === 'left' && isPulled.overflowX > this.pullLimit) {\n        this.initialPositionX = 0;\n      }\n      if (isPulled.edge === 'right' && isPulled.overflowX > this.pullLimit) {\n        this.initialPositionX = positionX;\n      }\n    }\n  }\n  getMovePositionX() {\n    const distance = this.getDistance();\n    return this.initialElementPositionX - distance;\n  }\n  getDistance() {\n    return this.startX - this.moveX;\n  }\n  /* If the container is pulled out of the left or right border */\n  detectPulled() {\n    const currentPositionX = this.getCurrentPositionX();\n    if (currentPositionX > 0) {\n      return {\n        edge: 'left',\n        positionX: currentPositionX,\n        overflowX: Math.abs(currentPositionX)\n      };\n    }\n    if (currentPositionX < this.getEndPosition()) {\n      return {\n        edge: 'right',\n        positionX: currentPositionX,\n        overflowX: Math.abs(currentPositionX - this.getEndPosition())\n      };\n    }\n    return undefined;\n  }\n  slowdownOnPull(_positionX) {\n    let distance = Math.abs(this.getDistance());\n    const endPosition = this.getEndPosition();\n    const isPulled = this.detectPulled();\n    if (!isPulled) {\n      return 0;\n    }\n    const decelerationRatio = 3 + isPulled.overflowX / 50;\n    let positionX = 0;\n    if (isPulled.edge === 'left') {\n      if (this.initialElementPositionX < 0) {\n        distance = distance - Math.abs(this.initialElementPositionX);\n      }\n      const rubberPositionX = distance / decelerationRatio;\n      positionX = rubberPositionX;\n      if (this.initialElementPositionX > 0) {\n        positionX = this.initialElementPositionX + rubberPositionX;\n      }\n      if (positionX > this.pullLimit) {\n        positionX = this.pullLimit;\n      }\n    }\n    if (isPulled.edge === 'right') {\n      const rubberPositionX = endPosition + (this.initialElementPositionX - distance - endPosition) / decelerationRatio;\n      const containerWidth = this.getWidth();\n      positionX = rubberPositionX;\n      if (this.initialElementPositionX < -(containerWidth - this.visibleWidth)) {\n        positionX = containerWidth - this.visibleWidth + this.initialElementPositionX + rubberPositionX;\n      }\n      if (positionX < endPosition - this.pullLimit) {\n        positionX = endPosition - this.pullLimit;\n      }\n    }\n    return positionX;\n  }\n  finishMoving() {\n    const positionX = this.getMovePositionX();\n    let newPositionX = 0;\n    if (this.freeScroll) {\n      newPositionX = this.getInertia();\n    }\n    /* Align container while pulling */\n    newPositionX = this.getAlignedPositionOnPull(newPositionX);\n    this.transformPositionX(newPositionX);\n    this.setInitialPosition(positionX);\n  }\n  /* Returns the new position of the container with inertia */\n  getInertia() {\n    const distance = this.getDistance();\n    const currentTime = new Date().getTime();\n    const tapLength = currentTime - this.startTime;\n    let inertia = distance / tapLength * 100;\n    return this.initialPositionX - inertia;\n  }\n  getAlignedPositionOnPull(newPositionX) {\n    const direction = this.getDirection();\n    if (direction === 'left') {\n      let endPosition = this.getEndPosition();\n      if (newPositionX < endPosition) {\n        return endPosition;\n      }\n    }\n    if (direction === 'right') {\n      if (newPositionX > 0) {\n        return 0;\n      }\n    }\n    return newPositionX;\n  }\n  getCurrentPositionX() {\n    const parentPosition = this.element.parentElement.getBoundingClientRect();\n    const position = this.element.getBoundingClientRect();\n    return position.left - parentPosition.left;\n  }\n  getEndPosition() {\n    if (this.isLightDOM) {\n      let imagesInContainer = this.cells.imageUtils.getImages();\n      return -(imagesInContainer.length * this.fullCellWidth - this.visibleWidth - this.margin);\n    } else {\n      const width = this.getWidth();\n      const visibleWidth = this.element.parentElement.clientWidth;\n      return visibleWidth - width;\n    }\n  }\n  transformPositionX(value, duration = this.transitionDuration) {\n    if (value === undefined) {\n      return;\n    }\n    this.element.style.transition = 'transform ' + duration + 'ms ' + this.transitionTimingFunction;\n    this.element.style.transform = 'translateX(' + value + 'px)';\n  }\n  getWidth() {\n    let width = this.cellLengthInLightDOMMode * this.fullCellWidth;\n    let totalImageWidth = this.cellLength * this.fullCellWidth;\n    if (totalImageWidth < width) {\n      width = totalImageWidth;\n    }\n    return this.isLightDOM ? width : totalImageWidth;\n  }\n  setWidth() {\n    const width = this.getWidth();\n    this.element.style.width = width + \"px\";\n  }\n  setInitialPosition(position) {\n    this.initialPositionX = position;\n  }\n  getElementPosition() {\n    return this.element.getBoundingClientRect();\n  }\n  getInitialElementPositionX() {\n    const carouselElementPosition = this.utils.getCarouselElementPosition()['left'];\n    return this.getElementPosition()['left'] - carouselElementPosition;\n  }\n  clearInitialValues() {\n    this.startX = this.moveX = 0;\n  }\n  getDirection() {\n    const direction = Math.sign(this.startX - this.moveX);\n    if (direction === -1) {\n      return 'right';\n    }\n    if (direction === 1) {\n      return 'left';\n    }\n    return undefined;\n  }\n}\nclass ImageUtils {\n  constructor(element) {\n    this.cellStack = [];\n    this.element = element;\n  }\n  getImages() {\n    return this.cellStack.filter(this.filter);\n  }\n  filter(cell) {\n    return cell.img !== undefined;\n  }\n}\nclass Cells {\n  constructor(carouselProperties, utils) {\n    this.carouselProperties = carouselProperties;\n    this.utils = utils;\n    this.counter = 0;\n    this.imageUtils = new ImageUtils(this.element);\n    this.init(carouselProperties);\n  }\n  get images() {\n    return this.carouselProperties.images;\n  }\n  get cellLength() {\n    return this.cells ? this.cells.length : 0;\n  }\n  get fullCellWidth() {\n    return this.carouselProperties.cellWidth + this.carouselProperties.margin;\n  }\n  get cellLengthInLightDOMMode() {\n    if (this.images) {\n      let cellLength = this.numberOfVisibleCells + this.overflowCellsLimit * 2;\n      if (cellLength > this.images.length) {\n        cellLength = this.images.length;\n      }\n      return cellLength;\n    } else {\n      return this.cellLength;\n    }\n  }\n  get numberOfVisibleCells() {\n    return this.utils.numberOfVisibleCells;\n  }\n  get overflowCellsLimit() {\n    return this.utils.overflowCellsLimit;\n  }\n  get isLightDOM() {\n    return this.carouselProperties.lightDOM || this.carouselProperties.loop;\n  }\n  updateProperties(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n  }\n  lineUp() {\n    const cells = this.element ? this.element.children : [];\n    this.imageUtils.cellStack = [];\n    for (var i = 0; i < cells.length; i++) {\n      let cell = cells[i];\n      let positionX = this.getCellPositionInContainer(i);\n      cell.style.transform = 'translateX(' + positionX + 'px)';\n      cell.style.width = this.carouselProperties.cellWidth + 'px';\n      if (this.getImage(i)) {\n        this.imageUtils.cellStack.push({\n          index: i,\n          positionX,\n          img: this.getImage(i)['image']\n        });\n      }\n    }\n    ;\n  }\n  ifSequenceOfCellsIsChanged() {\n    const cells = this.element.children;\n    return cells[0]['style'].transform !== 'translateX(0px)';\n  }\n  getCellPositionInContainer(cellIndexInDOMTree) {\n    let positionIndex = this.getCellIndexInContainer(cellIndexInDOMTree);\n    return positionIndex * this.fullCellWidth;\n  }\n  getCellIndexInContainer(cellIndexInDOMTree) {\n    let positionIndex;\n    if (!this.isLightDOM) {\n      return cellIndexInDOMTree;\n    }\n    let cellLength = this.cellLengthInLightDOMMode;\n    let counter = this.counter - this.overflowCellsLimit;\n    if (counter > cellLength) {\n      counter = counter % cellLength;\n    }\n    if (counter < 0) {\n      return cellIndexInDOMTree;\n    } else {\n      positionIndex = cellIndexInDOMTree - counter;\n      if (positionIndex < 0) {\n        positionIndex = cellLength + positionIndex;\n      }\n    }\n    return positionIndex;\n  }\n  getImage(cellIndex) {\n    if (!this.images) {\n      return;\n    }\n    let imageIndex = this.getImageIndex(cellIndex);\n    let file = this.images[imageIndex];\n    if (file && !file.type) {\n      file.type = 'image';\n    }\n    return {\n      image: this.images[imageIndex],\n      imageIndex\n    };\n  }\n  getImageIndex(cellIndexInDOMTree) {\n    const positionIndex = this.getCellIndexInContainer(cellIndexInDOMTree);\n    let imageIndex;\n    if (this.counter > this.overflowCellsLimit) {\n      let cellLimitOverflow = this.counter - this.overflowCellsLimit;\n      imageIndex = positionIndex + cellLimitOverflow;\n      if (this.images && this.carouselProperties.loop) {\n        imageIndex = imageIndex % this.images.length;\n      }\n    } else {\n      imageIndex = cellIndexInDOMTree;\n    }\n    return imageIndex;\n  }\n  setCounter(value) {\n    this.counter = value;\n  }\n  init(carouselProperties) {\n    this.element = this.carouselProperties.cellsElement;\n    this.cells = this.element.children;\n    this.visibleWidth = this.carouselProperties.visibleWidth || this.element.parentElement.clientWidth;\n  }\n}\nclass Slide {\n  constructor(carouselProperties, utils, cells, container) {\n    this.carouselProperties = carouselProperties;\n    this.utils = utils;\n    this.cells = cells;\n    this.container = container;\n    this.slideLength = 0;\n    this.isSlideInProgress = false;\n    this.counter = 0;\n    this._counter = 0;\n    this.distance = 0;\n    this.distanceAbs = 0;\n    this.isNotClickOnArrow = false;\n    this.initialPositionX = 0;\n    this.currentPositionX = 0;\n    /* The slide length has been limited by the limitSlideLength() method */\n    this.isSlideLengthLimited = false;\n    this.init();\n  }\n  get fullCellWidth() {\n    return this.carouselProperties.cellWidth + this.carouselProperties.margin;\n  }\n  get margin() {\n    return this.carouselProperties.margin;\n  }\n  get minSwipeDistance() {\n    return this.carouselProperties.minSwipeDistance;\n  }\n  get numberOfVisibleCells() {\n    return this.utils.numberOfVisibleCells;\n  }\n  get visibleCellsOverflowContainer() {\n    return this.utils.visibleCellsOverflowContainer;\n  }\n  /* The position to which the container returns after each slide\r\n   * in the light DUM tree mode.\r\n   */\n  get fixedContainerPosition() {\n    return -(this.overflowCellsLimit * this.fullCellWidth);\n  }\n  get overflowCellsLimit() {\n    return this.utils.overflowCellsLimit;\n  }\n  get images() {\n    return this.carouselProperties.images;\n  }\n  /* Number of cell elements in the DUM tree */\n  get cellLength() {\n    if (this.isLightDOM) {\n      return this.cells.cellLengthInLightDOMMode;\n    } else {\n      if (this.images) {\n        return this.images.length;\n      } else {\n        return this.cells.cellLength;\n      }\n    }\n  }\n  get isLightDOM() {\n    return this.carouselProperties.lightDOM || this.carouselProperties.loop;\n  }\n  updateProperties(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n    this.setVisibleWidth();\n  }\n  init() {\n    this.visibleWidth = this.carouselProperties.visibleWidth || this.carouselProperties.hostElement.clientWidth;\n  }\n  handleTouchstart() {\n    /* Touchstart event is not called for arrow */\n    this.isNotClickOnArrow = true;\n    this.isSlideLengthLimited = false;\n    if (!this.isSlideInProgress) {\n      this.initialPositionX = this.container.getCurrentPositionX();\n    }\n  }\n  handleTouchend() {\n    if (!this.isNotClickOnArrow) {\n      return;\n    }\n    this.currentPositionX = this.container.getCurrentPositionX();\n    this.distanceAbs = Math.abs(this.initialPositionX - this.currentPositionX);\n    this.distance = this.initialPositionX - this.currentPositionX;\n    this.direction = this.getDirection();\n    this.isNotClickOnArrow = false;\n    this.handleSlide();\n  }\n  handleTransitionend() {\n    this.setCounter();\n    this.isSlideInProgress = false;\n    if (this.isLightDOM) {\n      this.alignContainerFast();\n    }\n  }\n  handleSlide(customSlideLength = undefined) {\n    let isUsingButton = customSlideLength;\n    let newPositionX;\n    if (isUsingButton && this.isSlideInProgress || !this.direction) {\n      return;\n    }\n    /* Custom slide length is used in arrows */\n    if (customSlideLength) {\n      this.slideLength = this.limitSlideLength(customSlideLength);\n      if (!this.isSlideInProgress) {\n        this.initialPositionX = this.container.getCurrentPositionX();\n      }\n    } else {\n      this.slideLength = this.getSlideLength(this.distanceAbs);\n    }\n    /* Store intermediate counter value */\n    this._counter = this.getPreliminaryCounter();\n    if (this.direction === 'left') {\n      if (!customSlideLength) {\n        this.slideLength = this.limitSlideLength(this.getSlideLength(this.distanceAbs));\n      }\n      this._counter = this.getPreliminaryCounter();\n      let isSlidesEnd = this.isSlidesEnd(this._counter);\n      newPositionX = this.getPositionByIndex(this._counter);\n      if (isSlidesEnd) {\n        this._counter = this.counter;\n        newPositionX = this.getPositionByIndex(this.counter);\n        this.slideLength = 0;\n      }\n    }\n    if (this.direction === 'right') {\n      if (!customSlideLength) {\n        this.slideLength = this.getSlideLength(this.distanceAbs);\n      }\n      if (this._counter < 0) {\n        this._counter = this.counter;\n        this.slideLength = this.counter;\n      }\n      newPositionX = this.getPositionByIndex(this.counter - this.slideLength);\n    }\n    if (this.container.getCurrentPositionX() !== newPositionX) {\n      this.isSlideInProgress = true;\n      this.container.transformPositionX(newPositionX);\n    }\n  }\n  next(length = 1) {\n    this.direction = 'left';\n    this.handleSlide(length);\n  }\n  prev(length = 1) {\n    this.direction = 'right';\n    this.handleSlide(length);\n  }\n  select(index) {\n    if (index > this.cellLength - 1) {\n      return;\n    }\n    if (index > this.counter) {\n      let length = index - this.counter;\n      this.next(length);\n    }\n    if (index < this.counter) {\n      let length = this.counter - index;\n      this.prev(length);\n    }\n  }\n  getPreliminaryCounter() {\n    if (this.direction === 'left') {\n      return this.counter + this.slideLength;\n    }\n    if (this.direction === 'right') {\n      return this.counter - this.slideLength;\n    }\n    return 0;\n  }\n  /*\r\n   * Limits the length of the slide during calls to the next() and prev()\r\n   * methods if the specified position is outside the cell length\r\n   */\n  limitSlideLength(slideLength) {\n    if (slideLength > 1) {\n      for (var i = 0; i < slideLength; i++) {\n        let newCounter = this.counter + (slideLength - i);\n        if (!this.isSlidesEnd(newCounter)) {\n          slideLength = slideLength - i;\n          this.isSlideLengthLimited = i > 0;\n          break;\n        }\n      }\n    }\n    return slideLength;\n  }\n  /* Offset the container to show the last cell completely */\n  getPositionCorrection(counter) {\n    let correction = 0;\n    let isLastSlide = this.isLastSlide(counter);\n    if (this.carouselProperties.loop || this.direction === \"right\") {\n      return 0;\n    }\n    if (this.isSlideLengthLimited || isLastSlide) {\n      let cellsWidth = this.cells.cellLengthInLightDOMMode * this.fullCellWidth;\n      if (this.visibleWidth < cellsWidth) {\n        correction = -(this.numberOfVisibleCells * this.fullCellWidth - this.visibleWidth - this.margin);\n      }\n      if (correction >= -this.margin) {\n        correction = 0;\n      }\n    }\n    return correction;\n  }\n  getSlideLength(distanceAbs) {\n    let isLastSlide = this.isLastSlide(this.counter);\n    /* If the last cell does not fit entirely, then the\r\n     * length of the swipe to the left, from the extreme\r\n     * right position, may be shorter than usual.\r\n     */\n    if (isLastSlide && this.direction === \"right\") {\n      distanceAbs = distanceAbs + this.visibleWidth % this.fullCellWidth;\n    }\n    let length = Math.floor(distanceAbs / this.fullCellWidth);\n    if (distanceAbs % this.fullCellWidth >= this.minSwipeDistance) {\n      length++;\n    }\n    return length;\n  }\n  getDistanceAbs() {\n    return Math.abs(this.initialPositionX - this.currentPositionX);\n  }\n  getDirection() {\n    const direction = Math.sign(this.initialPositionX - this.currentPositionX);\n    if (direction === -1) {\n      return 'right';\n    }\n    if (direction === 1) {\n      return 'left';\n    }\n    return undefined;\n  }\n  isSlidesEnd(counter) {\n    let margin = this.visibleCellsOverflowContainer ? 1 : 0;\n    let imageLength = this.images ? this.images.length : this.cells.cellLength;\n    if (this.carouselProperties.loop) {\n      return false;\n    } else {\n      return imageLength - counter + margin < this.numberOfVisibleCells;\n    }\n  }\n  isLastSlide(counter) {\n    return this.isSlidesEnd(counter + 1);\n  }\n  setCounter() {\n    if (this.direction === 'left') {\n      this.counter = this.counter + this.slideLength;\n    }\n    if (this.direction === 'right') {\n      this.counter = this.counter - this.slideLength;\n    }\n  }\n  getPositionByIndex(_counter) {\n    let correction = this.getPositionCorrection(this.counter + this.slideLength);\n    let position;\n    if (correction !== 0) {\n      correction = correction + this.fullCellWidth;\n    }\n    if (this.direction === 'right') {\n      correction = 0;\n    }\n    if (this.isLightDOM && this.isLightDOMMode(_counter) || this.isLightDOM && this.ifLeftDOMModeAtEnd(_counter)) {\n      let initialPosition = this.getPositionWithoutCorrection(this.initialPositionX);\n      let counterDifference = _counter - this.counter;\n      position = initialPosition - (counterDifference * this.fullCellWidth - correction);\n    } else {\n      position = -(_counter * this.fullCellWidth - correction);\n    }\n    position = this.provideSafePosition(position);\n    return position;\n  }\n  provideSafePosition(position) {\n    const endPosition = this.container.getEndPosition();\n    if (this.direction === 'left') {\n      if (position > 0) {\n        position = 0;\n      }\n    }\n    if (this.direction === 'right') {\n      if (position < endPosition) {\n        position = endPosition;\n      }\n    }\n    return position;\n  }\n  getPositionWithoutCorrection(value) {\n    let remainder = Math.round(value) % this.fullCellWidth;\n    if (remainder !== 0) {\n      return value - (this.fullCellWidth + remainder);\n    } else {\n      return value;\n    }\n  }\n  isNextArrowDisabled() {\n    return this.isLastSlide(this.counter) || !this.visibleCellsOverflowContainer && this.cellLength <= this.numberOfVisibleCells || this.visibleCellsOverflowContainer && this.cellLength < this.numberOfVisibleCells;\n  }\n  isPrevArrowDisabled() {\n    return this.counter === 0;\n  }\n  alignContainerFast() {\n    if (this.isLightDOMMode(this.counter)) {\n      let positionX = this.fixedContainerPosition;\n      this.container.transformPositionX(positionX, 0);\n      this.cells.setCounter(this.counter);\n      this.cells.lineUp();\n    } else if (this.ifLeftDOMModeToBeginning(this.counter)) {\n      /* If we have already exited the light DOM mode but\r\n       * the cells are still out of place\r\n       */\n      if (this.cells.ifSequenceOfCellsIsChanged()) {\n        let positionX = -(this.counter * this.fullCellWidth);\n        this.container.transformPositionX(positionX, 0);\n        this.cells.setCounter(this.counter);\n        this.cells.lineUp();\n      }\n    } else if (this.ifLeftDOMModeAtEnd(this.counter)) {\n      let containerPositionX = this.container.getCurrentPositionX();\n      let containerWidth = this.container.getWidth();\n      this.visibleWidth;\n      if (this.isLastSlide(this.counter) && containerWidth + containerPositionX >= this.visibleWidth) {\n        return;\n      }\n      let correction = this.getPositionCorrection(this.counter);\n      if (correction !== 0) {\n        correction = correction + this.fullCellWidth;\n      }\n      if (this.direction === 'right') {\n        correction = 0;\n      }\n      let positionX = this.fixedContainerPosition + correction;\n      this.container.transformPositionX(positionX, 0);\n      this.cells.setCounter(this.counter);\n      this.cells.lineUp();\n    }\n  }\n  isLightDOMMode(counter) {\n    let flag;\n    let remainderOfCells = this.images.length - this.overflowCellsLimit - this.numberOfVisibleCells;\n    if (!this.isLightDOM) {\n      return false;\n    }\n    if (counter > this.overflowCellsLimit && this.direction === \"left\" && counter <= remainderOfCells) {\n      flag = true;\n    }\n    if (counter >= this.overflowCellsLimit && this.direction === \"right\" && counter < remainderOfCells) {\n      flag = true;\n    }\n    if (this.counter > this.overflowCellsLimit && this.direction === \"left\" && this.counter <= remainderOfCells) {\n      flag = true;\n    }\n    if (this.counter >= this.overflowCellsLimit && this.direction === \"right\" && this.counter < remainderOfCells) {\n      flag = true;\n    }\n    return flag;\n  }\n  ifLeftDOMModeAtEnd(counter) {\n    let flag;\n    let remainderOfCells = this.images.length - this.overflowCellsLimit - this.numberOfVisibleCells;\n    if (counter >= remainderOfCells) {\n      flag = true;\n    }\n    if (this.counter >= remainderOfCells) {\n      flag = true;\n    }\n    return flag;\n  }\n  ifLeftDOMModeToBeginning(counter) {\n    let flag;\n    if (counter <= this.overflowCellsLimit) {\n      flag = true;\n    }\n    if (this.counter <= this.overflowCellsLimit) {\n      flag = true;\n    }\n    return flag;\n  }\n  setVisibleWidth() {\n    this.visibleWidth = this.carouselProperties.visibleWidth || this.carouselProperties.hostElement.clientWidth;\n  }\n}\nclass Utils {\n  constructor(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n  }\n  get images() {\n    return this.carouselProperties.images;\n  }\n  get margin() {\n    return this.carouselProperties.margin;\n  }\n  get overflowCellsLimit() {\n    if (this.images && this.isImagesLessCellLimit) {\n      let overflowCellsLimit = Math.floor((this.images.length - this.numberOfVisibleCells) / 2);\n      if (overflowCellsLimit < 0) {\n        overflowCellsLimit = 0;\n      }\n      return overflowCellsLimit;\n    } else {\n      return this.carouselProperties.overflowCellsLimit;\n    }\n  }\n  get isImagesLessCellLimit() {\n    return this.carouselProperties.overflowCellsLimit * 2 + this.numberOfVisibleCells > this.images.length;\n  }\n  get numberOfVisibleCells() {\n    return Math.ceil(this.visibleWidth / this.fullCellWidth);\n  }\n  get visibleCellsOverflowContainer() {\n    return this.numberOfVisibleCells * this.fullCellWidth - this.margin > this.visibleWidth;\n  }\n  get fullCellWidth() {\n    return this.carouselProperties.cellWidth + this.carouselProperties.margin;\n  }\n  get visibleWidth() {\n    return this.carouselProperties.visibleWidth || this.carouselProperties.cellsElement.parentElement.clientWidth;\n  }\n  updateProperties(carouselProperties) {\n    this.carouselProperties = carouselProperties;\n  }\n  getStartX(event) {\n    const touches = event.touches;\n    const carouselElementPosition = this.getCarouselElementPosition()['left'];\n    let startX;\n    if (touches) {\n      startX = touches[0].clientX - carouselElementPosition;\n    } else {\n      startX = event.clientX - carouselElementPosition;\n    }\n    return startX;\n  }\n  getMoveX(event) {\n    const touches = event.touches;\n    const carouselElementPositionX = this.getCarouselElementPosition()['left'];\n    if (touches) {\n      return touches[0].clientX - carouselElementPositionX;\n    } else {\n      return event.clientX - carouselElementPositionX;\n    }\n  }\n  getCarouselElementPosition() {\n    return this.carouselProperties.hostElement.getBoundingClientRect();\n  }\n}\nlet CarouselComponent = /*#__PURE__*/(() => {\n  class CarouselComponent {\n    constructor(elementRef, ref) {\n      this.elementRef = elementRef;\n      this.ref = ref;\n      this.minTimeout = 30;\n      this.isVideoPlaying = false;\n      this._isCounter = false;\n      this._cellWidth = 200;\n      this._loop = false;\n      this._lightDOM = false;\n      this.isMoving = false;\n      this.isNgContent = false;\n      this.events = new EventEmitter();\n      this.height = 200;\n      this.autoplay = false;\n      this.autoplayInterval = 5000;\n      this.pauseOnHover = true;\n      this.dots = false;\n      this.margin = 10;\n      this.objectFit = 'cover';\n      this.minSwipeDistance = 10;\n      this.transitionDuration = 200;\n      this.transitionTimingFunction = 'ease-out';\n      this.counterSeparator = \" / \";\n      this.overflowCellsLimit = 3;\n      this.listeners = 'mouse and touch';\n      this.cellsToScroll = 1;\n      this.freeScroll = false;\n      this.arrows = true;\n      this.arrowsOutside = false;\n      this.arrowsTheme = 'light';\n      this.hostClassCarousel = true;\n      this.handleTouchstart = event => {\n        this.touches.addEventListeners(\"mousemove\", \"handleMousemove\");\n        this.carousel.handleTouchstart(event);\n        this.isMoving = true;\n      };\n      this.handleHorizontalSwipe = event => {\n        event.preventDefault();\n        this.carousel.handleHorizontalSwipe(event);\n      };\n      this.handleTouchend = event => {\n        const touches = event.touches;\n        this.carousel.handleTouchend(event);\n        this.touches.removeEventListeners(\"mousemove\", \"handleMousemove\");\n        this.isMoving = false;\n      };\n      this.handleTap = event => {\n        let outboundEvent = {\n          name: 'click'\n        };\n        let nodes = Array.prototype.slice.call(this.cellsElement.children);\n        let cellElement = event.srcElement.closest(\".carousel-cell\");\n        const i = nodes.indexOf(cellElement);\n        const cellIndex = nodes.indexOf(cellElement);\n        if (this.images) {\n          //outboundEvent.fileIndex = this.carousel.getFileIndex(i);\n          //outboundEvent.file = this.carousel.getFile(cellIndex);\n        } else {\n          outboundEvent.cellIndex = cellIndex;\n        }\n      };\n    }\n    get isContainerLocked() {\n      if (this.carousel) {\n        return this.carousel.isContainerLocked;\n      }\n    }\n    get slideCounter() {\n      if (this.carousel) {\n        return this.carousel.slideCounter;\n      }\n    }\n    get lapCounter() {\n      if (this.carousel) {\n        return this.carousel.lapCounter;\n      }\n    }\n    get isLandscape() {\n      return window.innerWidth > window.innerHeight;\n    }\n    get isSafari() {\n      const ua = navigator.userAgent.toLowerCase();\n      if (ua.indexOf('safari') !== -1) {\n        return !(ua.indexOf('chrome') > -1);\n      }\n    }\n    get counter() {\n      let counter;\n      if (this.loop) {\n        counter = this.slideCounter % this.cellLength;\n      } else {\n        counter = this.slideCounter;\n      }\n      return counter + 1 + this.counterSeparator + this.cellLength;\n    }\n    get cellsElement() {\n      return this.elementRef.nativeElement.querySelector('.carousel-cells');\n    }\n    get isArrows() {\n      return this.arrows && !this.freeScroll;\n    }\n    get isCounter() {\n      return this._isCounter && this.cellLength > 1;\n    }\n    get activeDotIndex() {\n      return this.slideCounter % this.cellLength;\n    }\n    get cellLimit() {\n      if (this.carousel) {\n        return this.carousel.cellLimit;\n      }\n    }\n    get carouselWidth() {\n      return this.elementRef.nativeElement.clientWidth;\n    }\n    set images(images) {\n      this._images = images;\n    }\n    get images() {\n      return this._images;\n    }\n    set cellWidth(value) {\n      if (value) {\n        this._cellWidth = value;\n      }\n    }\n    set isCounter(value) {\n      if (value) {\n        this._isCounter = value;\n      }\n    }\n    set loop(value) {\n      if (value) {\n        this._loop = value;\n      }\n    }\n    get loop() {\n      if (this.images) {\n        return this._loop;\n      } else {\n        return false;\n      }\n    }\n    set lightDOM(value) {\n      if (value) {\n        this._lightDOM = value;\n      }\n    }\n    get lightDOM() {\n      if (this.images) {\n        return this._lightDOM;\n      } else {\n        return false;\n      }\n    }\n    onWindowResize(event) {\n      if (this.utils.visibleWidth !== this.savedCarouselWidth) {\n        this.resize();\n      }\n    }\n    onMousemove(event) {\n      if (this.autoplay && this.pauseOnHover) {\n        this.carousel.stopAutoplay();\n      }\n    }\n    onMouseleave(event) {\n      if (this.autoplay && this.pauseOnHover) {\n        this.carousel.autoplay();\n      }\n    }\n    ngOnInit() {\n      this.isNgContent = this.cellsElement.children.length > 0;\n      this.touches = new Touches({\n        element: this.cellsElement,\n        listeners: this.listeners,\n        mouseListeners: {\n          \"mousedown\": \"handleMousedown\",\n          \"mouseup\": \"handleMouseup\"\n        }\n      });\n      this.touches.on('touchstart', this.handleTouchstart);\n      this.touches.on('horizontal-swipe', this.handleHorizontalSwipe);\n      this.touches.on('touchend', this.handleTouchend);\n      this.touches.on('mousedown', this.handleTouchstart);\n      this.touches.on('mouseup', this.handleTouchend);\n      this.touches.on('tap', this.handleTap);\n      this.setDimensions();\n    }\n    ngAfterViewInit() {\n      this.initCarousel();\n      this.cellLength = this.getCellLength();\n      this.dotsArr = Array(this.cellLength).fill(1);\n      this.ref.detectChanges();\n      this.carousel.lineUpCells();\n      this.savedCarouselWidth = this.carouselWidth;\n      /* Start detecting changes in the DOM tree */\n      this.detectDomChanges();\n    }\n    ngOnChanges(changes) {\n      if (changes.width || changes.height || changes.images) {\n        this.setDimensions();\n        this.initCarousel();\n        this.carousel.lineUpCells();\n        this.ref.detectChanges();\n      }\n    }\n    ngOnDestroy() {\n      this.touches.destroy();\n      //this.carousel.destroy();\n    }\n\n    initCarousel() {\n      this.carouselProperties = {\n        id: this.id,\n        cellsElement: this.elementRef.nativeElement.querySelector('.carousel-cells'),\n        hostElement: this.elementRef.nativeElement,\n        images: this.images,\n        cellWidth: this.getCellWidth(),\n        loop: this.loop,\n        autoplayInterval: this.autoplayInterval,\n        overflowCellsLimit: this.overflowCellsLimit,\n        visibleWidth: this.width,\n        margin: this.margin,\n        minSwipeDistance: this.minSwipeDistance,\n        transitionDuration: this.transitionDuration,\n        transitionTimingFunction: this.transitionTimingFunction,\n        videoProperties: this.videoProperties,\n        eventHandler: this.events,\n        freeScroll: this.freeScroll,\n        lightDOM: this.lightDOM\n      };\n      this.utils = new Utils(this.carouselProperties);\n      this.cells = new Cells(this.carouselProperties, this.utils);\n      this.container = new Container(this.carouselProperties, this.utils, this.cells);\n      this.slide = new Slide(this.carouselProperties, this.utils, this.cells, this.container);\n      this.carousel = new Carousel(this.carouselProperties, this.utils, this.cells, this.container, this.slide);\n      if (this.autoplay) {\n        this.carousel.autoplay();\n      }\n    }\n    resize() {\n      this.landscapeMode = this.isLandscape;\n      this.savedCarouselWidth = this.carouselWidth;\n      this.carouselProperties.cellWidth = this.getCellWidth();\n      this.cells.updateProperties(this.carouselProperties);\n      this.carousel.updateProperties(this.carouselProperties);\n      this.container.updateProperties(this.carouselProperties);\n      this.slide.updateProperties(this.carouselProperties);\n      this.utils.updateProperties(this.carouselProperties);\n      this.carousel.lineUpCells();\n      this.slide.select(0);\n      this.ref.detectChanges();\n    }\n    detectDomChanges() {\n      const observer = new MutationObserver(mutations => {\n        this.onDomChanges();\n      });\n      var config = {\n        attributes: true,\n        childList: true,\n        characterData: true\n      };\n      observer.observe(this.cellsElement, config);\n    }\n    onDomChanges() {\n      this.cellLength = this.getCellLength();\n      this.carousel.lineUpCells();\n      this.ref.detectChanges();\n    }\n    setDimensions() {\n      this.hostStyleHeight = this.height + 'px';\n      this.hostStyleWidth = this.width + 'px';\n    }\n    getImage(index) {\n      return this.carousel.getImage(index);\n    }\n    handleTransitionendCellContainer(event) {\n      if (event.target['className'] === 'carousel-cells') {\n        this.carousel.handleTransitionend();\n      }\n    }\n    getCellWidth() {\n      let elementWidth = this.carouselWidth;\n      if (this.cellsToShow) {\n        let margin = this.cellsToShow > 1 ? this.margin : 0;\n        let totalMargin = margin * (this.cellsToShow - 1);\n        return (elementWidth - totalMargin) / this.cellsToShow;\n      }\n      if (this._cellWidth === '100%') {\n        return elementWidth;\n      } else {\n        return this._cellWidth;\n      }\n    }\n    next() {\n      this.carousel.next(this.cellsToScroll);\n      this.carousel.stopAutoplay();\n    }\n    prev() {\n      this.carousel.prev(this.cellsToScroll);\n      this.carousel.stopAutoplay();\n    }\n    isNextArrowDisabled() {\n      if (this.carousel) {\n        return this.carousel.isNextArrowDisabled();\n      }\n    }\n    isPrevArrowDisabled() {\n      if (this.carousel) {\n        return this.carousel.isPrevArrowDisabled();\n      }\n    }\n    getCellLength() {\n      if (this.images) {\n        return this.images.length;\n      } else {\n        return this.cellsElement.children.length;\n      }\n    }\n  }\n  CarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n    return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  CarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselComponent,\n    selectors: [[\"carousel\"], [\"\", \"carousel\", \"\"]],\n    hostVars: 6,\n    hostBindings: function CarouselComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function CarouselComponent_resize_HostBindingHandler($event) {\n          return ctx.onWindowResize($event);\n        }, false, i0.ɵɵresolveWindow)(\"mousemove\", function CarouselComponent_mousemove_HostBindingHandler($event) {\n          return ctx.onMousemove($event);\n        })(\"mouseleave\", function CarouselComponent_mouseleave_HostBindingHandler($event) {\n          return ctx.onMouseleave($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"height\", ctx.hostStyleHeight)(\"width\", ctx.hostStyleWidth);\n        i0.ɵɵclassProp(\"carousel\", ctx.hostClassCarousel);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      height: \"height\",\n      width: \"width\",\n      autoplay: \"autoplay\",\n      autoplayInterval: \"autoplayInterval\",\n      pauseOnHover: \"pauseOnHover\",\n      dots: \"dots\",\n      borderRadius: \"borderRadius\",\n      margin: \"margin\",\n      objectFit: \"objectFit\",\n      minSwipeDistance: \"minSwipeDistance\",\n      transitionDuration: \"transitionDuration\",\n      transitionTimingFunction: \"transitionTimingFunction\",\n      videoProperties: \"videoProperties\",\n      counterSeparator: \"counterSeparator\",\n      overflowCellsLimit: \"overflowCellsLimit\",\n      listeners: \"listeners\",\n      cellsToShow: \"cellsToShow\",\n      cellsToScroll: \"cellsToScroll\",\n      freeScroll: \"freeScroll\",\n      arrows: \"arrows\",\n      arrowsOutside: \"arrowsOutside\",\n      arrowsTheme: \"arrowsTheme\",\n      images: \"images\",\n      cellWidth: \"cellWidth\",\n      isCounter: [\"counter\", \"isCounter\"],\n      loop: \"loop\",\n      lightDOM: \"lightDOM\"\n    },\n    outputs: {\n      events: \"events\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 8,\n    vars: 6,\n    consts: [[\"class\", \"carousel-counter\", 4, \"ngIf\"], [1, \"carousel-container\"], [1, \"carousel-cells\", 3, \"transitionend\"], [\"cells\", \"\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"class\", \"carousel-dots\", 4, \"ngIf\"], [\"class\", \"carousel-arrows\", 3, \"carousel-arrows-outside\", \"carousel-dark-arrows\", 4, \"ngIf\"], [1, \"carousel-counter\"], [\"class\", \"carousel-cell\", 3, \"width\", \"border-radius\", 4, \"ngIf\"], [1, \"carousel-cell\"], [\"draggable\", \"false\", 3, \"src\", \"object-fit\", 4, \"ngIf\"], [\"draggable\", \"false\", 3, \"src\"], [1, \"carousel-dots\"], [\"class\", \"carousel-dot\", 3, \"carousel-dot-active\", 4, \"ngFor\", \"ngForOf\"], [1, \"carousel-dot\"], [1, \"carousel-arrows\"], [1, \"carousel-arrow\", \"carousel-arrow-prev\", 3, \"click\"], [1, \"carousel-arrow\", \"carousel-arrow-next\", 3, \"click\"]],\n    template: function CarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, CarouselComponent_div_0_Template, 2, 1, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1)(2, \"div\", 2, 3);\n        i0.ɵɵlistener(\"transitionend\", function CarouselComponent_Template_div_transitionend_2_listener($event) {\n          return ctx.handleTransitionendCellContainer($event);\n        });\n        i0.ɵɵprojection(4);\n        i0.ɵɵtemplate(5, CarouselComponent_ng_template_5_Template, 1, 1, \"ng-template\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, CarouselComponent_div_6_Template, 2, 1, \"div\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, CarouselComponent_div_7_Template, 3, 8, \"div\", 6);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.isCounter);\n        i0.ɵɵadvance(1);\n        i0.ɵɵclassProp(\"carousel-moving\", ctx.isMoving);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngForOf\", ctx.images);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.dots);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.isArrows);\n      }\n    },\n    dependencies: [i1.NgIf, i1.NgForOf],\n    styles: [\"[_nghost-%COMP%]{position:relative;display:block;top:0;left:0;width:100%;height:100%;-webkit-user-select:none;user-select:none;z-index:10000;transform-origin:top left;box-sizing:border-box}[_nghost-%COMP%]   .carousel-container[_ngcontent-%COMP%]{overflow:hidden;width:100%;height:100%;cursor:grab}[_nghost-%COMP%]   .carousel-container.carousel-moving[_ngcontent-%COMP%]{cursor:grabbing}[_nghost-%COMP%]   .carousel-counter[_ngcontent-%COMP%]{text-align:right;position:absolute;z-index:30;transition:opacity .2s;top:8px;right:24px;border-radius:13px;background-color:#1725444d;font-size:11px;color:#fff;padding:5px 7px;line-height:normal}[_nghost-%COMP%]     .carousel-cells{transition:transform .2s;width:100%;height:100%;display:block;will-change:transform}[_nghost-%COMP%]     .carousel-cells .carousel-cell.swiper-prev-image{transform:translate3d(-100%,0,0)}[_nghost-%COMP%]     .carousel-cells .carousel-cell.swiper-next-image{transform:translate3d(100%,0,0)}[_nghost-%COMP%]     .carousel-cells .carousel-cell{width:100%;height:100%;position:absolute;overflow:hidden}[_nghost-%COMP%]     .carousel-cells .carousel-cell img, [_nghost-%COMP%]     .carousel-cells .carousel-cell video{width:100%;height:100%;position:relative;object-fit:contain}[_nghost-%COMP%]     .carousel-cells .carousel-cell img.swiper-hide{display:none}[_nghost-%COMP%]     .carousel-cells .carousel-cell .carousel-play{position:absolute;top:0;left:0;bottom:0;right:0;z-index:1}[_nghost-%COMP%]   .carousel-arrow[_ngcontent-%COMP%]{width:40px;height:40px;background-color:#fff;background-repeat:no-repeat;background-size:31px;background-position:50%;border-radius:100px;position:absolute;top:50%;margin-top:-20px;z-index:10;cursor:pointer;box-shadow:0 0 5px #00000026}[_nghost-%COMP%]   .carousel-arrow-prev[_ngcontent-%COMP%]{left:10px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMTUuNDEgMTYuNTlMMTAuODMgMTJsNC41OC00LjU5TDE0IDZsLTYgNiA2IDYgMS40MS0xLjQxeiIvPjxwYXRoIGQ9Ik0wIDBoMjR2MjRIMFYweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==)}[_nghost-%COMP%]   .carousel-arrow-next[_ngcontent-%COMP%]{right:10px;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNOC41OSAxNi41OUwxMy4xNyAxMiA4LjU5IDcuNDEgMTAgNmw2IDYtNiA2LTEuNDEtMS40MXoiLz48cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=)}[_nghost-%COMP%]   .carousel-arrows-outside[_ngcontent-%COMP%]   .carousel-arrow-prev[_ngcontent-%COMP%]{left:-60px}[_nghost-%COMP%]   .carousel-arrows-outside[_ngcontent-%COMP%]   .carousel-arrow-next[_ngcontent-%COMP%]{right:-60px}[_nghost-%COMP%]   .carousel-dark-arrows[_ngcontent-%COMP%]   .carousel-arrow[_ngcontent-%COMP%]{filter:invert(1)}[_nghost-%COMP%]   .carousel-arrow-disabled[_ngcontent-%COMP%]{cursor:default;opacity:.5}[_nghost-%COMP%]   .carousel-dots[_ngcontent-%COMP%]{position:absolute;left:0;right:0;bottom:0;z-index:10;text-align:center}[_nghost-%COMP%]   .carousel-dots[_ngcontent-%COMP%]   .carousel-dot[_ngcontent-%COMP%]{display:inline-block;border:2px solid #fff;border-radius:100px;margin:4px;width:8px;height:8px}[_nghost-%COMP%]   .carousel-dots[_ngcontent-%COMP%]   .carousel-dot-active[_ngcontent-%COMP%]{background-color:#fff}\"]\n  });\n  return CarouselComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IvyCarouselModule = /*#__PURE__*/(() => {\n  class IvyCarouselModule {}\n  IvyCarouselModule.ɵfac = function IvyCarouselModule_Factory(t) {\n    return new (t || IvyCarouselModule)();\n  };\n  IvyCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IvyCarouselModule\n  });\n  IvyCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [],\n    imports: [[CommonModule]]\n  });\n  return IvyCarouselModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\r\n * Public API Surface of angular-responsive-carousel\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CarouselComponent, IvyCarouselModule };\n//# sourceMappingURL=angular-responsive-carousel.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}